// --- WARTEN BIS DAS DOKUMENT GELADEN IST ---
document.addEventListener('DOMContentLoaded', () => {

                                                  // --- GRUNDLEGENDE ELEMENTE ---
                                                  const cipherSelect = document.getElementById('cipher-select');
                                                      const settingsContainer = document.getElementById('settings-container');
                                                      const infoBox = document.getElementById('info-box');

                                                      const chatA = document.getElementById('chat-a');
                                                      const inputA = document.getElementById('input-a');
                                                      const sendA = document.getElementById('send-a');

                                                      const chatB = document.getElementById('chat-b');
                                                      const inputB = document.getElementById('input-b');
                                                      const sendB = document.getElementById('send-b');

                                                      const ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';

                                                  // --- ENIGMA KONFIGURATION ---
                                                  const ENIGMA_CONFIG = {
                                                      rotors: {
                                                  'I':   { wiring: 'EKMFLGDQVZNTOWYHXUSPAIBRCJ', notch: 'Q' },
                                                  'II':  { wiring: 'AJDKSIRUXBLHWTMCQGZNPYFVOE', notch: 'E' },
                                                  'III': { wiring: 'BDFHJLCPRTXVZNYEIWGAKMUSQO', notch: 'V' }
                                                  },
                                                  reflector: {
                                                  'B': 'YRUHQSLDPXNGOKMIEBFZCWVJAT'
                                                  }
                                                  };

                                                      let messageCounter = 0;

                                                  // --- VERSCHLÃœSSELUNGSFUNKTIONEN ---

                                                  function atbash(text) {
                                                      return text.toUpperCase().split('').map(char => {
                                                      const index = ALPHABET.indexOf(char);
                                                      if (index !== -1) {
                                                      return ALPHABET[ALPHABET.length - 1 - index];
                                                  }
                                                      return char;
                                                  }).join('');
                                                  }

                                                      function caesar(text, shift) {
                                                      return text.toUpperCase().split('').map(char => {
                                                      const index = ALPHABET.indexOf(char);
                                                      if (index !== -1) {
                                                      return ALPHABET[(index + shift + ALPHABET.length) % ALPHABET.length];
                                                  }
                                                      return char;
                                                  }).join('');
                                                  }

                                                      function vigenere(text, key, encrypt = true) {
                                                      const keyUpper = key.toUpperCase().replace(/[^A-Z]/g, '');
                                                      if (keyUpper.length === 0) return text;
                                                      let keyIndex = 0;
                                                      return text.toUpperCase().split('').map(char => {
                                                      const charIndex = ALPHABET.indexOf(char);
                                                      if (charIndex !== -1) {
                                                      const keyChar = keyUpper[keyIndex % keyUpper.length];
                                                      const keyShift = ALPHABET.indexOf(keyChar);
                                                      keyIndex++;
                                                      const shift = encrypt ? keyShift : -keyShift;
                                                      return ALPHABET[(charIndex + shift + ALPHABET.length) % ALPHABET.length];
                                                  }
                                                      return char;
                                                  }).join('');
                                                  }

                                                      function railFence(text, rails, encrypt = true) {
                                                      if (rails <= 1) return text;
                                                      const fence = Array.from({ length: rails }, () => []);
                                                      if (encrypt) {
                                                      let rail = 0;
                                                      let direction = 1;
                                                      for (const char of text) {
                                                      fence[rail].push(char);
                                                      rail += direction;
                                                      if (rail === 0 || rail === rails - 1) {
                                                      direction *= -1;
                                                  }
                                                  }
                                                      return fence.flat().join('');
                                                  } else { // Decrypt
                                                    const len = text.length;
                                                        let rail = 0;
                                                        let direction = 1;
                                                        const fenceLengths = Array(rails).fill(0);
                                                        for (let i = 0; i < len; i++) {
                                                        fenceLengths[rail]++;
                                                        rail += direction;
                                                        if (rail === 0 || rail === rails - 1) {
                                                        direction *= -1;
                                                    }
                                                    }

                                                        const textChars = text.split('');
                                                    for(let i=0; i<rails; i++) {
                                                        fence[i] = textChars.splice(0, fenceLengths[i]);
                                                    }

                                                        let result = '';
                                                        rail = 0;
                                                        direction = 1;
                                                        for (let i = 0; i < len; i++) {
                                                        result += fence[rail].shift();
                                                        rail += direction;
                                                        if (rail === 0 || rail === rails - 1) {
                                                        direction *= -1;
                                                    }
                                                    }
                                                        return result;
                                                    }
                                                  }

                                                      function enigma(text, settings) {
                                                      let { rotorOrder, rotorPositions } = settings;
                                                      if (!rotorOrder || rotorOrder.length < 3 || rotorOrder.includes(null)) return text.toUpperCase();

                                                      let pos = [...rotorPositions];

                                                      function rotate() {
                                                  // Double-step anomaly is not implemented for simplicity
                                                  if (ALPHABET[pos[1]] === ENIGMA_CONFIG.rotors[rotorOrder[1]].notch) {
                                                      pos[0] = (pos[0] + 1) % 26;
                                                      pos[1] = (pos[1] + 1) % 26;
                                                  }
                                                      if (ALPHABET[pos[2]] === ENIGMA_CONFIG.rotors[rotorOrder[2]].notch) {
                                                      pos[1] = (pos[1] + 1) % 26;
                                                  }
                                                      pos[2] = (pos[2] + 1) % 26;
                                                  }

                                                      return text.toUpperCase().split('').map(char => {
                                                      if (ALPHABET.indexOf(char) === -1) return char;

                                                  rotate();

                                                      let signal = ALPHABET.indexOf(char);

                                                  // Forward pass
                                                  for (let i = 2; i >= 0; i--) {
                                                      const rotor = ENIGMA_CONFIG.rotors[rotorOrder[i]];
                                                      const entryIndex = (signal + pos[i]) % 26;
                                                      const exitChar = rotor.wiring[entryIndex];
                                                      signal = (ALPHABET.indexOf(exitChar) - pos[i] + 26) % 26;
                                                  }

                                                  // Reflector
                                                  signal = ALPHABET.indexOf(ENIGMA_CONFIG.reflector.B[signal]);

                                                  // Backward pass
                                                  for (let i = 0; i < 3; i++) {
                                                      const rotor = ENIGMA_CONFIG.rotors[rotorOrder[i]];
                                                      const entryIndex = (signal + pos[i]) % 26;
                                                      const exitIndex = rotor.wiring.indexOf(ALPHABET[entryIndex]);
                                                      signal = (exitIndex - pos[i] + 26) % 26;
                                                  }

                                                      return ALPHABET[signal];
                                                  }).join('');
                                                  }

                                                  // --- UI-UPDATE FUNKTIONEN ---

                                                  const settingsHTML = {
                                                      atbash: `<p class="text-gray-400">Atbash benÃ¶tigt keine weiteren Einstellungen. Jeder Buchstabe wird einfach durch sein GegenstÃ¼ck im Alphabet ersetzt (Aâ†”Z, Bâ†”Y...).</p>`,
                                                  caesar: `
                                                  <div class="flex items-center gap-4">
                                                  <label for="caesar-shift" class="text-sm font-bold text-gray-300">Verschiebung:</label>
                                                  <input type="range" id="caesar-shift" min="1" max="25" value="3" class="w-full">
                                                  <span id="caesar-shift-value" class="font-bold text-green-400 w-8 text-center">3</span>
                                                  </div>`,
                                                  vigenere: `
                                                  <div class="flex items-center gap-4">
                                                  <label for="vigenere-key" class="text-sm font-bold text-gray-300">SchlÃ¼sselwort:</label>
                                                  <input type="text" id="vigenere-key" class="w-full bg-gray-700 border border-gray-600 rounded-lg p-2 focus:outline-none focus:ring-2 focus:ring-green-400" placeholder="GEHEIM">
                                                  </div>`,
                                                  railfence: `
                                                  <div class="flex items-center gap-4">
                                                  <label for="railfence-rails" class="text-sm font-bold text-gray-300">Schienen:</label>
                                                  <input type="range" id="railfence-rails" min="2" max="5" value="2" class="w-full">
                                                  <span id="railfence-rails-value" class="font-bold text-green-400 w-8 text-center">2</span>
                                                  </div>`,
                                                  enigma: `
                                                  <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                                                  <div>
                                                  <p class="text-sm font-bold text-gray-300 mb-2">1. Walzenlage (Drag & Drop)</p>
                                                  <div class="flex justify-around items-center bg-gray-900 p-2 rounded-lg">
                                                  <div id="rotor-basket" class="flex gap-2 p-2 border-2 border-dashed border-gray-600 rounded-md">
                                                  <!-- Walzen werden hier eingefÃ¼gt -->
                                                  </div>
                                                  <div class="text-2xl text-gray-500 mx-4">â†’</div>
                                                  <div id="rotor-slots" class="flex gap-2">
                                                  <!-- Slots werden hier eingefÃ¼gt -->
                                                  </div>
                                                  </div>
                                                  </div>
                                                  <div>
                                                  <p class="text-sm font-bold text-gray-300 mb-2">2. Grundstellung (Klicken zum Ã„ndern)</p>
                                                  <div id="rotor-positions" class="flex justify-around items-center bg-gray-900 p-2 rounded-lg h-full">
                                                  <!-- Positionen werden hier eingefÃ¼gt -->
                                                  </div>
                                                  </div>
                                                  </div>`
                                                  };

                                                      const infoTexts = {
                                                      atbash: `
                                                      <h3 class="text-2xl font-display text-green-400 mb-2">Atbash-Chiffre</h3>
                                                      <p><b>Funktionsweise:</b> Dies ist eine der einfachsten Substitutionschiffren. Das Alphabet wird einfach "umgedreht". Der erste Buchstabe (A) wird zum letzten (Z), der zweite (B) zum vorletzten (Y) und so weiter.</p>
                                                  <p class="mt-2"><b>SchlÃ¼ssel:</b> Es gibt keinen SchlÃ¼ssel. Die Methode ist fest und kann von jedem, der sie kennt, sofort entschlÃ¼sselt werden.</p>
                                                  <p class="mt-2"><b>SchwÃ¤che:</b> Extrem unsicher. Da die Methode fest ist und Buchstaben immer auf die gleiche Weise ersetzt werden, kann sie durch eine einfache HÃ¤ufigkeitsanalyse leicht geknackt werden.</p>`,
                                                  caesar: `
                                                  <h3 class="text-2xl font-display text-green-400 mb-2">Caesar-Chiffre</h3>
                                                  <p><b>Funktionsweise:</b> Jeder Buchstabe im Klartext wird um eine feste Anzahl von Positionen im Alphabet verschoben. Eine Verschiebung von 3 wÃ¼rde A zu D, B zu E usw. machen.</p>
                                                  <p class="mt-2"><b>SchlÃ¼ssel:</b> Die Zahl, um die verschoben wird (1-25). Alice und Bob mÃ¼ssen beide dieselbe Zahl kennen.</p>
                                                  <p class="mt-2"><b>SchwÃ¤che:</b> Sehr unsicher. Da es nur 25 mÃ¶gliche SchlÃ¼ssel gibt, kann ein Angreifer einfach alle MÃ¶glichkeiten durchprobieren (Brute-Force-Angriff).</p>`,
                                                  vigenere: `
                                                  <h3 class="text-2xl font-display text-green-400 mb-2">VigenÃ¨re-Chiffre</h3>
                                                  <p><b>Funktionsweise:</b> Ã„hnlich wie Caesar, aber die Verschiebung Ã¤ndert sich fÃ¼r jeden Buchstaben. Die Verschiebungen werden durch ein SchlÃ¼sselwort bestimmt. Ist das SchlÃ¼sselwort "AUTO", wird der 1. Buchstabe um 0 (A) verschoben, der 2. um 20 (U), der 3. um 19 (T), der 4. um 14 (O), der 5. wieder um 0 (A) usw.</p>
                                                  <p class="mt-2"><b>SchlÃ¼ssel:</b> Das SchlÃ¼sselwort. Es sollte mÃ¶glichst lang und schwer zu erraten sein.</p>
                                                  <p class="mt-2"><b>SchwÃ¤che:</b> Sicherer als Caesar, da die HÃ¤ufigkeitsanalyse nicht direkt funktioniert. Wurde aber im 19. Jahrhundert geknackt, indem man die LÃ¤nge des SchlÃ¼sselworts herausfand und dann fÃ¼r jeden Buchstaben eine separate Caesar-Analyse durchfÃ¼hrte.</p>`,
                                                  railfence: `
                                                  <h3 class="text-2xl font-display text-green-400 mb-2">Zick-Zack-Chiffre (Rail Fence)</h3>
                                                  <p><b>Funktionsweise:</b> Eine Transpositionschiffre. Die Buchstaben werden nicht ersetzt, sondern nur umsortiert. Man schreibt den Text im Zick-Zack Ã¼ber eine bestimmte Anzahl von Zeilen ("Schienen") und liest dann die Zeilen nacheinander aus. "HALLO WELT" auf 2 Schienen wird zu "H L O E T A L W L".</p>
                                                  <p class="mt-2"><b>SchlÃ¼ssel:</b> Die Anzahl der Schienen.</p>
                                                  <p class="mt-2"><b>SchwÃ¤che:</b> Relativ unsicher, besonders bei wenigen Schienen. Ein Angreifer kann die Originalnachricht durch Ausprobieren verschiedener Schienenanzahlen schnell wiederherstellen.</p>`,
                                                  enigma: `
                                                  <h3 class="text-2xl font-display text-green-400 mb-2">Enigma-Maschine</h3>
                                                  <p><b>Funktionsweise:</b> Eine elektromechanische Chiffriermaschine, die im 2. Weltkrieg eingesetzt wurde. Jeder Tastendruck dreht eine oder mehrere der Walzen (Rotoren), wodurch sich die VerschlÃ¼sselung fÃ¼r jeden einzelnen Buchstaben Ã¤ndert. Der Strom flieÃŸt durch die Walzen, wird von einem Reflektor zurÃ¼ckgeschickt und geht einen anderen Weg zurÃ¼ck.</p>
                                                  <p class="mt-2"><b>SchlÃ¼ssel:</b> Die gesamte Tageseinstellung: 1. Welche Walzen verwendet werden und in welcher Reihenfolge (Walzenlage). 2. Die Anfangsposition jeder Walze (Grundstellung). 3. (In der RealitÃ¤t) Das Steckerbrett, das Buchstabenpaare vertauscht.</p>
                                                  <p class="mt-2"><b>SchwÃ¤che:</b> Obwohl extrem komplex, wurde die Enigma von den Alliierten (u.a. durch Alan Turing) geknackt. SchwÃ¤chen waren, dass ein Buchstabe nie zu sich selbst verschlÃ¼sselt werden konnte und menschliche Fehler bei der Bedienung gemacht wurden.</p>`
                                                  };

                                                      function updateUI() {
                                                      const selectedCipher = cipherSelect.value;
                                                      settingsContainer.innerHTML = settingsHTML[selectedCipher];
                                                      infoBox.innerHTML = infoTexts[selectedCipher];

                                                  // Event Listener fÃ¼r die neuen Elemente hinzufÃ¼gen
                                                  if (selectedCipher === 'caesar') {
                                                      const slider = document.getElementById('caesar-shift');
                                                      const valueSpan = document.getElementById('caesar-shift-value');
                                                      slider.addEventListener('input', () => valueSpan.textContent = slider.value);
                                                  } else if (selectedCipher === 'railfence') {
                                                      const slider = document.getElementById('railfence-rails');
                                                      const valueSpan = document.getElementById('railfence-rails-value');
                                                      slider.addEventListener('input', () => valueSpan.textContent = slider.value);
                                                  } else if (selectedCipher === 'enigma') {
                                                  setupEnigmaUI();
                                                  }
                                                  }

                                                  // --- ENIGMA UI LOGIK ---
                                                  function setupEnigmaUI() {
                                                      const rotorBasket = document.getElementById('rotor-basket');
                                                      const rotorSlots = document.getElementById('rotor-slots');
                                                      const rotorPositions = document.getElementById('rotor-positions');

                                                      rotorBasket.innerHTML = '';
                                                      rotorSlots.innerHTML = '';
                                                      rotorPositions.innerHTML = '';

                                                  // Walzen im Korb erstellen
                                                  Object.keys(ENIGMA_CONFIG.rotors).forEach(rotorId => {
                                                      const rotorEl = document.createElement('div');
                                                      rotorEl.id = `rotor-${rotorId}`;
                                                      rotorEl.dataset.rotorId = rotorId;
                                                      rotorEl.className = 'rotor bg-gray-600 text-white w-12 h-12 flex items-center justify-center rounded-md font-bold text-xl border-2 border-gray-500';
                                                      rotorEl.textContent = rotorId;
                                                      rotorEl.draggable = true;
                                                      rotorBasket.appendChild(rotorEl);
                                                  });

                                                  // Slots und Positionsanzeigen erstellen
                                                  for (let i = 0; i < 3; i++) {
                                                      const slotEl = document.createElement('div');
                                                      slotEl.id = `slot-${i}`;
                                                      slotEl.dataset.slotIndex = i;
                                                      slotEl.className = 'rotor-slot bg-gray-700 w-12 h-12 rounded-md border-2 border-dashed border-gray-500 flex items-center justify-center';
                                                      rotorSlots.appendChild(slotEl);

                                                      const posEl = document.createElement('div');
                                                      posEl.id = `pos-${i}`;
                                                      posEl.dataset.posIndex = i;
                                                      posEl.className = 'rotor-position-char bg-gray-700 text-white w-12 h-12 flex items-center justify-center rounded-full font-bold text-2xl cursor-pointer';
                                                      posEl.textContent = 'A';
                                                      rotorPositions.appendChild(posEl);
                                                  }

                                                  addEnigmaEventListeners();
                                                  }

                                                      function addEnigmaEventListeners() {
                                                      const rotors = document.querySelectorAll('.rotor');
                                                      const slots = document.querySelectorAll('.rotor-slot');

                                                      rotors.forEach(rotor => {
                                                      rotor.addEventListener('dragstart', e => {
                                                      e.dataTransfer.setData('text/plain', e.target.id);
                                                  setTimeout(() => e.target.classList.add('invisible'), 0);
                                                  });
                                                      rotor.addEventListener('dragend', e => {
                                                      e.target.classList.remove('invisible');
                                                  });
                                                  });

                                                      slots.forEach(slot => {
                                                      slot.addEventListener('dragover', e => {
                                                      e.preventDefault();
                                                      slot.classList.add('drag-over');
                                                  });
                                                      slot.addEventListener('dragleave', () => {
                                                      slot.classList.remove('drag-over');
                                                  });
                                                      slot.addEventListener('drop', e => {
                                                      e.preventDefault();
                                                      slot.classList.remove('drag-over');
                                                      const rotorElementId = e.dataTransfer.getData('text/plain');
                                                      const rotorEl = document.getElementById(rotorElementId);

                                                      if (slot.firstChild) {
                                                      document.getElementById('rotor-basket').appendChild(slot.firstChild);
                                                  }
                                                      slot.appendChild(rotorEl);
                                                  });
                                                  });

                                                      document.getElementById('rotor-basket').addEventListener('dragover', e => {
                                                      e.preventDefault();
                                                      e.target.classList.add('drag-over');
                                                  });
                                                      document.getElementById('rotor-basket').addEventListener('dragleave', e => {
                                                      e.target.classList.remove('drag-over');
                                                  });
                                                      document.getElementById('rotor-basket').addEventListener('drop', e => {
                                                      e.preventDefault();
                                                      e.target.classList.remove('drag-over');
                                                      const rotorElementId = e.dataTransfer.getData('text/plain');
                                                      const rotorEl = document.getElementById(rotorElementId);
                                                      e.target.appendChild(rotorEl);
                                                  });


                                                      document.querySelectorAll('.rotor-position-char').forEach(pos => {
                                                      pos.addEventListener('click', () => {
                                                      let currentIndex = ALPHABET.indexOf(pos.textContent);
                                                      currentIndex = (currentIndex + 1) % 26;
                                                      pos.textContent = ALPHABET[currentIndex];
                                                  });
                                                  });
                                                  }

                                                  // --- NACHRICHTEN LOGIK ---

                                                  function getSettings() {
                                                      const cipher = cipherSelect.value;
                                                      const settings = { cipher };

                                                      switch (cipher) {
                                                      case 'caesar':
                                                      const slider = document.getElementById('caesar-shift');
                                                      settings.shift = slider ? parseInt(slider.value) : 3;
                                                      break;
                                                      case 'vigenere':
                                                      const keyInput = document.getElementById('vigenere-key');
                                                      settings.key = keyInput ? keyInput.value.toUpperCase() : 'GEHEIM';
                                                      break;
                                                      case 'railfence':
                                                      const railsSlider = document.getElementById('railfence-rails');
                                                      settings.rails = railsSlider ? parseInt(railsSlider.value) : 2;
                                                      break;
                                                      case 'enigma':
                                                      const rotorOrder = [];
                                                      const rotorPositions = [];
                                                      document.querySelectorAll('#rotor-slots .rotor').forEach(r => rotorOrder.push(r.dataset.rotorId));
                                                      document.querySelectorAll('#rotor-positions .rotor-position-char').forEach(p => rotorPositions.push(ALPHABET.indexOf(p.textContent)));
                                                      settings.rotorOrder = rotorOrder;
                                                      settings.rotorPositions = rotorPositions;
                                                      break;
                                                  }
                                                      return settings;
                                                  }

                                                      function sendMessage(from, to, text) {
                                                      if (!text.trim()) return;

                                                      const settings = getSettings();
                                                      let encryptedText = text;

                                                  // FÃ¼r Enigma muss eine Kopie der Einstellungen verwendet werden, da sich der Zustand Ã¤ndert
                                                  const enigmaSettingsForEncryption = JSON.parse(JSON.stringify(settings));

                                                      switch (settings.cipher) {
                                                      case 'atbash':
                                                      encryptedText = atbash(text);
                                                      break;
                                                      case 'caesar':
                                                      encryptedText = caesar(text, settings.shift);
                                                      break;
                                                      case 'vigenere':
                                                      encryptedText = vigenere(text, settings.key, true);
                                                      break;
                                                      case 'railfence':
                                                      encryptedText = railFence(text, settings.rails, true);
                                                      break;
                                                      case 'enigma':
                                                      encryptedText = enigma(text, enigmaSettingsForEncryption);
                                                      break;
                                                  }

                                                      messageCounter++;
                                                      const messageId = `msg-${messageCounter}`;

                                                      const fromChat = from === 'a' ? chatA : chatB;
                                                      const fromBubble = document.createElement('div');
                                                      fromBubble.className = 'chat-bubble ml-auto max-w-xs md:max-w-md p-3 rounded-lg bg-cyan-800 text-white self-end';
                                                      fromBubble.textContent = text;
                                                      fromChat.appendChild(fromBubble);

                                                      const toChat = to === 'a' ? chatA : chatB;
                                                      const toBubble = document.createElement('div');
                                                      toBubble.className = 'chat-bubble mr-auto max-w-xs md:max-w-md p-3 rounded-lg bg-gray-600 text-white';
                                                      toBubble.innerHTML = `
                                                  <div id="${messageId}" class="chat-bubble-encrypted p-2 rounded-md">${encryptedText}</div>
                                                  <button data-message-id="${messageId}" data-original-text="${text}" class="decrypt-btn mt-2 text-xs bg-green-500 hover:bg-green-600 text-white font-bold py-1 px-2 rounded transition-colors">EntschlÃ¼sseln</button>
                                                  `;
                                                      toChat.appendChild(toBubble);

                                                      fromChat.scrollTop = fromChat.scrollHeight;
                                                      toChat.scrollTop = toChat.scrollHeight;
                                                  }

                                                      function decryptMessage(button) {
                                                      const messageId = button.dataset.messageId;
                                                      const originalText = button.dataset.originalText;
                                                      const encryptedText = document.getElementById(messageId).textContent;

                                                      const settings = getSettings();
                                                      let decryptedText = encryptedText;

                                                  // FÃ¼r Enigma muss eine Kopie der Einstellungen verwendet werden
                                                  const enigmaSettingsForDecryption = JSON.parse(JSON.stringify(settings));

                                                  switch(settings.cipher) {
                                                      case 'atbash':
                                                      decryptedText = atbash(encryptedText);
                                                      break;
                                                      case 'caesar':
                                                      decryptedText = caesar(encryptedText, -settings.shift);
                                                      break;
                                                      case 'vigenere':
                                                      decryptedText = vigenere(encryptedText, settings.key, false);
                                                      break;
                                                      case 'railfence':
                                                      decryptedText = railFence(encryptedText, settings.rails, false);
                                                      break;
                                                      case 'enigma':
                                                      decryptedText = enigma(encryptedText, enigmaSettingsForDecryption);
                                                      break;
                                                  }

                                                      const messageDiv = document.getElementById(messageId);
                                                      messageDiv.textContent = decryptedText;
                                                      messageDiv.classList.remove('chat-bubble-encrypted');

                                                      if (decryptedText.toUpperCase() === originalText.toUpperCase()) {
                                                      messageDiv.style.backgroundColor = '#2a9d8f';
                                                      messageDiv.style.color = 'white';
                                                      messageDiv.style.border = '1px solid #2a9d8f';
                                                  } else {
                                                        messageDiv.style.backgroundColor = '#e76f51';
                                                        messageDiv.style.color = 'white';
                                                        messageDiv.style.border = '1px solid #e76f51';
                                                    }

                                                      button.remove();
                                                  }

                                                  // --- EVENT LISTENER INITIALISIERUNG ---
                                                  cipherSelect.addEventListener('change', updateUI);

                                                      sendA.addEventListener('click', () => {
                                                  sendMessage('a', 'b', inputA.value);
                                                      inputA.value = '';
                                                  });
                                                      inputA.addEventListener('keypress', (e) => {
                                                      if (e.key === 'Enter') {
                                                  sendMessage('a', 'b', inputA.value);
                                                      inputA.value = '';
                                                  }
                                                  });

                                                      sendB.addEventListener('click', () => {
                                                  sendMessage('b', 'a', inputB.value);
                                                      inputB.value = '';
                                                  });
                                                      inputB.addEventListener('keypress', (e) => {
                                                      if (e.key === 'Enter') {
                                                  sendMessage('b', 'a', inputB.value);
                                                      inputB.value = '';
                                                  }
                                                  });

                                                      document.body.addEventListener('click', (e) => {
                                                      if (e.target.classList.contains('decrypt-btn')) {
                                                  decryptMessage(e.target);
                                                  }
                                                  });

                                                  // --- INITIALER AUFRUF ---
                                                  updateUI();
                                                  });
